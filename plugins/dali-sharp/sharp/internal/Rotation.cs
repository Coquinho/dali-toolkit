//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (http://www.swig.org).
// Version 3.0.10
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------

namespace Dali {

public class Rotation : global::System.IDisposable {
  private global::System.Runtime.InteropServices.HandleRef swigCPtr;
  protected bool swigCMemOwn;

  internal Rotation(global::System.IntPtr cPtr, bool cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }

  internal static global::System.Runtime.InteropServices.HandleRef getCPtr(Rotation obj) {
    return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
  }

  ~Rotation() {
    DisposeQueue.Instance.Add(this);
  }

  public virtual void Dispose() {
    if (!Window.IsInstalled()) {
      DisposeQueue.Instance.Add(this);
      return;
    }

    lock(this) {
      if (swigCPtr.Handle != global::System.IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          NDalicPINVOKE.delete_Rotation(swigCPtr);
        }
        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
      global::System.GC.SuppressFinalize(this);
    }
  }


  public static Rotation operator+(Rotation arg1, Rotation arg2) {
    return arg1.Add(arg2);
  }

  public static Rotation operator-(Rotation arg1, Rotation arg2) {
    return arg1.Subtract(arg2);
  }

  public static Rotation operator-(Rotation arg1) {
    return arg1.Subtract();
  }

  public static Rotation operator*(Rotation arg1, Rotation arg2) {
    return arg1.Multiply(arg2);
  }

  public static Vector3 operator*(Rotation arg1, Vector3 arg2) {
    return arg1.Multiply(arg2);
  }

  public static Rotation operator*(Rotation arg1, float arg2) {
    return arg1.Multiply(arg2);
  }

  public static Rotation operator/(Rotation arg1, Rotation arg2) {
    return arg1.Divide(arg2);
  }

  public static Rotation operator/(Rotation arg1, float arg2) {
    return arg1.Divide(arg2);
  }

  public Rotation() : this(NDalicPINVOKE.new_Rotation__SWIG_0(), true) {
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
  }

  public Rotation(Radian angle, Vector3 axis) : this(NDalicPINVOKE.new_Rotation__SWIG_1(Radian.getCPtr(angle), Vector3.getCPtr(axis)), true) {
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
  }

  public static Rotation IDENTITY {
    get {
      global::System.IntPtr cPtr = NDalicPINVOKE.Rotation_IDENTITY_get();
      Rotation ret = (cPtr == global::System.IntPtr.Zero) ? null : new Rotation(cPtr, false);
      if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    } 
  }

  public bool IsIdentity() {
    bool ret = NDalicPINVOKE.Rotation_IsIdentity(swigCPtr);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public bool GetAxisAngle(Vector3 axis, Radian angle) {
    bool ret = NDalicPINVOKE.Rotation_GetAxisAngle(swigCPtr, Vector3.getCPtr(axis), Radian.getCPtr(angle));
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  private Rotation Add(Rotation other) {
    Rotation ret = new Rotation(NDalicPINVOKE.Rotation_Add(swigCPtr, Rotation.getCPtr(other)), true);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  private Rotation Subtract(Rotation other) {
    Rotation ret = new Rotation(NDalicPINVOKE.Rotation_Subtract__SWIG_0(swigCPtr, Rotation.getCPtr(other)), true);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  private Rotation Multiply(Rotation other) {
    Rotation ret = new Rotation(NDalicPINVOKE.Rotation_Multiply__SWIG_0(swigCPtr, Rotation.getCPtr(other)), true);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  private Vector3 Multiply(Vector3 other) {
    Vector3 ret = new Vector3(NDalicPINVOKE.Rotation_Multiply__SWIG_1(swigCPtr, Vector3.getCPtr(other)), true);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  private Rotation Divide(Rotation other) {
    Rotation ret = new Rotation(NDalicPINVOKE.Rotation_Divide__SWIG_0(swigCPtr, Rotation.getCPtr(other)), true);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  private Rotation Multiply(float scale) {
    Rotation ret = new Rotation(NDalicPINVOKE.Rotation_Multiply__SWIG_2(swigCPtr, scale), true);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  private Rotation Divide(float scale) {
    Rotation ret = new Rotation(NDalicPINVOKE.Rotation_Divide__SWIG_1(swigCPtr, scale), true);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  private Rotation Subtract() {
    Rotation ret = new Rotation(NDalicPINVOKE.Rotation_Subtract__SWIG_1(swigCPtr), true);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  private Rotation AddAssign(Rotation other) {
    Rotation ret = new Rotation(NDalicPINVOKE.Rotation_AddAssign(swigCPtr, Rotation.getCPtr(other)), false);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  private Rotation SubtractAssign(Rotation other) {
    Rotation ret = new Rotation(NDalicPINVOKE.Rotation_SubtractAssign(swigCPtr, Rotation.getCPtr(other)), false);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  private Rotation MultiplyAssign(Rotation other) {
    Rotation ret = new Rotation(NDalicPINVOKE.Rotation_MultiplyAssign__SWIG_0(swigCPtr, Rotation.getCPtr(other)), false);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  private Rotation MultiplyAssign(float scale) {
    Rotation ret = new Rotation(NDalicPINVOKE.Rotation_MultiplyAssign__SWIG_1(swigCPtr, scale), false);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  private Rotation DivideAssign(float scale) {
    Rotation ret = new Rotation(NDalicPINVOKE.Rotation_DivideAssign(swigCPtr, scale), false);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  private bool EqualTo(Rotation rhs) {
    bool ret = NDalicPINVOKE.Rotation_EqualTo(swigCPtr, Rotation.getCPtr(rhs));
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  private bool NotEqualTo(Rotation rhs) {
    bool ret = NDalicPINVOKE.Rotation_NotEqualTo(swigCPtr, Rotation.getCPtr(rhs));
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public float Length() {
    float ret = NDalicPINVOKE.Rotation_Length(swigCPtr);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public float LengthSquared() {
    float ret = NDalicPINVOKE.Rotation_LengthSquared(swigCPtr);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public void Normalize() {
    NDalicPINVOKE.Rotation_Normalize(swigCPtr);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
  }

  public Rotation Normalized() {
    Rotation ret = new Rotation(NDalicPINVOKE.Rotation_Normalized(swigCPtr), true);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public void Conjugate() {
    NDalicPINVOKE.Rotation_Conjugate(swigCPtr);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
  }

  public void Invert() {
    NDalicPINVOKE.Rotation_Invert(swigCPtr);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
  }

  public Rotation Log() {
    Rotation ret = new Rotation(NDalicPINVOKE.Rotation_Log(swigCPtr), true);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public Rotation Exp() {
    Rotation ret = new Rotation(NDalicPINVOKE.Rotation_Exp(swigCPtr), true);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float Dot(Rotation q1, Rotation q2) {
    float ret = NDalicPINVOKE.Rotation_Dot(Rotation.getCPtr(q1), Rotation.getCPtr(q2));
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Rotation Lerp(Rotation q1, Rotation q2, float t) {
    Rotation ret = new Rotation(NDalicPINVOKE.Rotation_Lerp(Rotation.getCPtr(q1), Rotation.getCPtr(q2), t), true);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Rotation Slerp(Rotation q1, Rotation q2, float progress) {
    Rotation ret = new Rotation(NDalicPINVOKE.Rotation_Slerp(Rotation.getCPtr(q1), Rotation.getCPtr(q2), progress), true);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Rotation SlerpNoInvert(Rotation q1, Rotation q2, float t) {
    Rotation ret = new Rotation(NDalicPINVOKE.Rotation_SlerpNoInvert(Rotation.getCPtr(q1), Rotation.getCPtr(q2), t), true);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Rotation Squad(Rotation start, Rotation end, Rotation ctrl1, Rotation ctrl2, float t) {
    Rotation ret = new Rotation(NDalicPINVOKE.Rotation_Squad(Rotation.getCPtr(start), Rotation.getCPtr(end), Rotation.getCPtr(ctrl1), Rotation.getCPtr(ctrl2), t), true);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float AngleBetween(Rotation q1, Rotation q2) {
    float ret = NDalicPINVOKE.Rotation_AngleBetween(Rotation.getCPtr(q1), Rotation.getCPtr(q2));
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

}

}
